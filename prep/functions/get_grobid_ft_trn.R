#' Extract TRNs from full text publications.
#'
#' Publications should have been parsed by GROBID from PDF to TEI XML.
#'
#' @param filepath Character. Filepath including directory portion. Filepath should end in ".tei.xml" extensions as generated by GROBID. If \code{doi} or \code{pmid} is not provided, filename should be either pmid or doi with "/" replaced by "+".
#' @param doi Character. Default = NULL in which case \code{doi} parsed from the filename. Provide only \code{doi} or \code{pmid}.
#' @param pmid Character or numeric. Default = NULL in which case \code{pmid} parsed from the filename. Provide only \code{doi} or \code{pmid}.
#' @param where Character. Default = "body" What part of the GROBID XML should be searched for TRNs? This paramater currently supports only "body" but may be further developed to allow to other sections or even arbitrary xpaths.
#' @param processed_dir Character. Default = NULL. Filepath of a directory to which processed file should be moved. By default, file will not be moved.
#' @param dedupe Logical. Default = TRUE. Whether to deduplicate repeated TRNs from the same \code{where}. Two instances of the same NCT from within "body" would be reduced to one, but two instances of the same NCT from different sections (if this becomes an option) would be maintained.
#' @param quiet Logical. Default = FALSE. Whether to inform user about whether TRNs found for each DOI.
#'
#' @return Tibble with 6 columns: `doi`, `pmid`, `n` (trn count from `source`), `trn`, `registry` (generated from TRN, not extracted from full-text), `body`
#'
#' @examples
#' \dontrun{get_grobid_ft_trn(dir_ls(here::here("data-raw", "fulltext-xml"))[1])}
#' \dontrun{purrr::map_dfr(dir_ls(here::here("data-raw", "fulltext-xml")), get_grobid_ft_trn}

get_grobid_ft_trn <- function(filepath,
                              doi = NULL,
                              pmid = NULL,
                              where = "body",
                              processed_dir = NULL,
                              dedupe = TRUE,
                              quiet = FALSE) {
  
  # Check for correct filetype
  if (!stringr::str_detect(filepath, ".tei.xml$")){
    rlang::abort("`filepath` must end in '.tei.xml'")
  }
  
  # Set/get id (doi or pmid)
  # Check that not both doi and pmid provided
  if (!purrr::is_null(doi) & !purrr::is_null(pmid)) {
    rlang::abort("Both `doi` and `pmid` provided. Provide only one.")
    
    # Check for correct doi and set id_type
  } else if (!purrr::is_null(doi) & purrr::is_null(pmid)) {
    
    id_type <-
      ifelse(
        stringr::str_detect(doi, "^10\\.\\d{4,9}/[-.;()/:\\w\\d]+$"),
        "doi",
        rlang::abort("Invalid `doi`")
      )
    
    id <- doi
    
    # Check for correct pmid and set id_type
  } else if (!purrr::is_null(pmid) & purrr::is_null(doi)) {
    
    id_type <-
      ifelse(
        stringr::str_detect(pmid, "^[0-9]{8}$"),
        "pmid",
        rlang::abort("Invalid `pmid`")
      )
    
    id <- as.numeric(pmid)
    
    # Get id from filepath if neither provided
  } else {
    
    id <-
      filepath %>%
      fs::path_file() %>%
      stringr::str_remove(".tei.xml$") %>%
      stringr::str_replace_all("\\+", "/")
    
    id_type <- case_when(
      stringr::str_detect(id, "^10\\.\\d{4,9}/[-.;()/:\\w\\d]+$") ~ "doi",
      stringr::str_detect(id, "^[0-9]{8}$") ~ "pmid"#,
      # TRUE ~ rlang::abort("`filepath` must have `pmid` or `doi`")
    )
    
    if (is.na(id_type)) {
      rlang::abort("`filepath` must have `pmid` or `doi`")
    }
    
    if (id_type == "doi") doi = id else pmid = as.numeric(id)
  }
  
  ft_xml <-
    xml2::read_xml(filepath)
  
  # For each where/source, get the text and check for TRNs, constructing a tibble
  # First create empty tibble
  # NOTE: This could be vectorized.
  trn_df <-
    tibble::tibble(
      doi = as.character(),
      pmid = as.numeric(),
      n = as.numeric(),
      trn = as.character(),
      registry = as.character(),
      source = as.character()
    )
  
  for (w in where) {
    
    nodeset <-
      switch(w,
             "body" = extract_grobid_body(ft_xml)#,
             # "annex" = extract_annex(ft_xml)
      )
    
    # 2021-02-16: Changed collapse to \n and update ctregistries to disallow newlines \n from non-word \W. This is to avoid false positives introduced when collapsing XML.
    trn <-
      nodeset %>%
      paste(collapse =  "\n") %>%
      ctregistries::which_trn()
    
    # If empty return without a dataframe
    # Not rlang::is_empty(trn)
    if (all(is.na(trn))) {
      if (!quiet) {
        rlang::inform(glue::glue("{id}: No TRNs found in {w}"))
      }
      next
    }
    
    # Deduplicate TRNs within a source/where, per user selection and by default
    if (dedupe) (trn <- unique(trn))
    
    trn_df <-
      tibble::enframe(trn, name = "n", value = "trn") %>%
      dplyr::mutate(
        doi = doi,
        pmid = pmid,
        registry = purrr::map_chr(trn, ctregistries::which_registry),
        source = w
      ) %>%
      dplyr::bind_rows(trn_df, .)
    
    if (!quiet) rlang::inform(glue::glue("{id}: TRNs found in {w}"))
    
  }
  
  # Move file if user specified
  if (!rlang::is_null(processed_dir)) {
    fs::dir_create(processed_dir)
    fs::file_move(filepath, processed_dir)
  }
  
  # Return TRN tibble if any found
  if (nrow(trn_df) != 0) return(trn_df)
}


#' Extract <body> nodeset from parsed GROBID publication
#'
#' <body> excludes <header> which has abstract
#'
#' @param xml_doc Parsed GROBID XML doc. Usually from \code{get_grobid_ft_trn}
#'
#' @return <body> nodeset of all descendant nodes

extract_grobid_body <- function(xml_doc){
  
  # Check for valid input: xml_document
  # NOTE: could also check whether coming from .tei.xml
  if (!"xml_document" %in% class(xml_doc)){
    rlang::abort("`xml_doc` must have class `xml_document`'")
  } #else if (!stringr::str_detect(xml_url(xml_doc), ".tei.xml$")){
  #   rlang::abort("`xml_doc` must end in '.tei.xml'")
  # }
  
  # Rename and reduce namespace to TEI (http://www.tei-c.org/ns/1.0)
  # Could also remove namespace with xml_ns_strip but probably should validate schema
  ns_tei <-
    xml2::xml_ns(xml_doc) %>%
    xml2::xml_ns_rename(d1 = "tei") %>%
    .["tei"]
  
  # 2021-02-18: Extract all descendants of <body> since collapsing as single text introduced false positives from <figure> <cell>
  #  10.1200/JCO.2012.46.4743 and "201802078126"
  #  10.1186/cc13089 and "nl11"
  #  10.1007/s00394-015-1084-x and "200400600800"
  xml2::xml_find_all(xml_doc, "//tei:text/tei:body/descendant::node()", ns_tei)
  # xml2::xml_find_first(xml_doc, "//tei:text/tei:body", ns_tei)
  # xml2::xml_find_all(xml_doc, "//tei:text/tei:body/tei:div", ns_tei)
}